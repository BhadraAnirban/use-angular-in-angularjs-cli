{
  "version": 3,
  "file": "lazyLoadNgModule.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/angular/lazyLoad/lazyLoadNgModule.ts"
  ],
  "names": [],
  "mappings": "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",
  "sourcesContent": [
    "/** @ng2api @module core */\n/** */\nimport { NgModuleRef, Injector, NgModuleFactory, Type, Compiler, NgModuleFactoryLoader } from '@angular/core';\nimport {\n  Transition,\n  LazyLoadResult,\n  UIRouter,\n  Resolvable,\n  NATIVE_INJECTOR_TOKEN,\n  isString,\n  unnestR,\n  inArray,\n  StateObject,\n  uniqR,\n  StateDeclaration,\n} from '@uirouter/core';\nimport { RootModule, UIROUTER_ROOT_MODULE, UIROUTER_MODULE_TOKEN, StatesModule } from '../uiRouterNgModule';\nimport { applyModuleConfig } from '../uiRouterConfig';\n\n/**\n * A function that returns an NgModule, or a promise for an NgModule\n *\n * #### Example:\n * ```js\n * export function loadFooModule() {\n *   return System.import('../foo/foo.module').then(result => result.FooModule);\n * }\n * ```\n */\nexport type ModuleTypeCallback = () => Type<any> | Promise<Type<any>>;\n/**\n * A string or a function which lazy loads a module\n *\n * If a string, should conform to the Angular Router `loadChildren` string.\n * #### Example:\n * ```\n * var ngModuleToLoad = './foo/foo.module#FooModule'\n * ```\n *\n * For functions, see: [[ModuleTypeCallback]]\n */\nexport type NgModuleToLoad = string | ModuleTypeCallback;\n\n/**\n * Returns a function which lazy loads a nested module\n *\n * This is primarily used by the [[ng2LazyLoadBuilder]] when processing [[Ng2StateDeclaration.loadChildren]].\n *\n * It could also be used manually as a [[StateDeclaration.lazyLoad]] property to lazy load an `NgModule` and its state(s).\n *\n * #### Example:\n * Using `System.import()` and named export of `HomeModule`\n * ```js\n * declare var System;\n * var futureState = {\n *   name: 'home.**',\n *   url: '/home',\n *   lazyLoad: loadNgModule(() => System.import('./home/home.module').then(result => result.HomeModule))\n * }\n * ```\n *\n * #### Example:\n * Using a path (string) to the module\n * ```js\n * var futureState = {\n *   name: 'home.**',\n *   url: '/home',\n *   lazyLoad: loadNgModule('./home/home.module#HomeModule')\n * }\n * ```\n *\n *\n * @param moduleToLoad a path (string) to the NgModule to load.\n *    Or a function which loads the NgModule code which should\n *    return a reference to  the `NgModule` class being loaded (or a `Promise` for it).\n *\n * @returns A function which takes a transition, which:\n * - Gets the Injector (scoped properly for the destination state)\n * - Loads and creates the NgModule\n * - Finds the \"replacement state\" for the target state, and adds the new NgModule Injector to it (as a resolve)\n * - Returns the new states array\n */\nexport function loadNgModule(\n  moduleToLoad: NgModuleToLoad\n): (transition: Transition, stateObject: StateDeclaration) => Promise<LazyLoadResult> {\n  return (transition: Transition, stateObject: StateDeclaration) => {\n    const ng2Injector = transition.injector().get(NATIVE_INJECTOR_TOKEN);\n\n    const createModule = (factory: NgModuleFactory<any>) => factory.create(ng2Injector);\n\n    const applyModule = (moduleRef: NgModuleRef<any>) => applyNgModule(transition, moduleRef, ng2Injector, stateObject);\n\n    return loadModuleFactory(moduleToLoad, ng2Injector)\n      .then(createModule)\n      .then(applyModule);\n  };\n}\n\n/**\n * Returns the module factory that can be used to instantiate a module\n *\n * For strings this:\n * - Finds the correct NgModuleFactoryLoader\n * - Loads the new NgModuleFactory from the path string (async)\n *\n * For a Type<any> or Promise<Type<any>> this:\n * - Compiles the component type (if not running with AOT)\n * - Returns the NgModuleFactory resulting from compilation (or direct loading if using AOT) as a Promise\n *\n * @internalapi\n */\nexport function loadModuleFactory(moduleToLoad: NgModuleToLoad, ng2Injector: Injector): Promise<NgModuleFactory<any>> {\n  if (isString(moduleToLoad)) {\n    return ng2Injector.get(NgModuleFactoryLoader).load(moduleToLoad);\n  }\n\n  const compiler: Compiler = ng2Injector.get(Compiler);\n  const offlineMode = compiler instanceof Compiler;\n\n  const unwrapEsModuleDefault = x => (x && x.__esModule && x['default'] ? x['default'] : x);\n  const compileAsync = (moduleType: Type<any>) => compiler.compileModuleAsync(moduleType);\n\n  const loadChildrenPromise = Promise.resolve(moduleToLoad()).then(unwrapEsModuleDefault);\n  return offlineMode ? loadChildrenPromise : loadChildrenPromise.then(compileAsync);\n}\n\n/**\n * Apply the UI-Router Modules found in the lazy loaded module.\n *\n * Apply the Lazy Loaded NgModule's newly created Injector to the right state in the state tree.\n *\n * Lazy loading uses a placeholder state which is removed (and replaced) after the module is loaded.\n * The NgModule should include a state with the same name as the placeholder.\n *\n * Find the *newly loaded state* with the same name as the *placeholder state*.\n * The NgModule's Injector (and ComponentFactoryResolver) will be added to that state.\n * The Injector/Factory are used when creating Components for the `replacement` state and all its children.\n *\n * @internalapi\n */\nexport function applyNgModule(\n  transition: Transition,\n  ng2Module: NgModuleRef<any>,\n  parentInjector: Injector,\n  lazyLoadState: StateDeclaration\n): LazyLoadResult {\n  const injector = ng2Module.injector;\n  const uiRouter: UIRouter = injector.get(UIRouter);\n  const registry = uiRouter.stateRegistry;\n\n  const originalName = lazyLoadState.name;\n  const originalState = registry.get(originalName);\n  // Check if it's a future state (ends with .**)\n  const isFuture = /^(.*)\\.\\*\\*$/.exec(originalName);\n  // Final name (without the .**)\n  const replacementName = isFuture && isFuture[1];\n\n  const newRootModules = multiProviderParentChildDelta(parentInjector, injector, UIROUTER_ROOT_MODULE).reduce(\n    uniqR,\n    []\n  ) as RootModule[];\n  const newChildModules = multiProviderParentChildDelta(parentInjector, injector, UIROUTER_MODULE_TOKEN).reduce(\n    uniqR,\n    []\n  ) as StatesModule[];\n\n  if (newRootModules.length) {\n    console.log(newRootModules); // tslint:disable-line:no-console\n    throw new Error('Lazy loaded modules should not contain a UIRouterModule.forRoot() module');\n  }\n\n  const newStateObjects: StateObject[] = newChildModules\n    .map(module => applyModuleConfig(uiRouter, injector, module))\n    .reduce(unnestR, [])\n    .reduce(uniqR, []);\n\n  if (isFuture) {\n    const replacementState = registry.get(replacementName);\n    if (!replacementState || replacementState === originalState) {\n      throw new Error(\n        `The Future State named '${originalName}' lazy loaded an NgModule. ` +\n          `The lazy loaded NgModule must have a state named '${replacementName}' ` +\n          `which replaces the (placeholder) '${originalName}' Future State. ` +\n          `Add a '${replacementName}' state to the lazy loaded NgModule ` +\n          `using UIRouterModule.forChild({ states: CHILD_STATES }).`\n      );\n    }\n  }\n\n  // Supply the newly loaded states with the Injector from the lazy loaded NgModule.\n  // If a tree of states is lazy loaded, only add the injector to the root of the lazy loaded tree.\n  // The children will get the injector by resolve inheritance.\n  const newParentStates = newStateObjects.filter(state => !inArray(newStateObjects, state.parent));\n\n  // Add the Injector to the top of the lazy loaded state tree as a resolve\n  newParentStates.forEach(state => state.resolvables.push(Resolvable.fromData(NATIVE_INJECTOR_TOKEN, injector)));\n\n  return {};\n}\n\n/**\n * Returns the new dependency injection values from the Child Injector\n *\n * When a DI token is defined as multi: true, the child injector\n * can add new values for the token.\n *\n * This function returns the values added by the child injector,  and excludes all values from the parent injector.\n *\n * @internalapi\n */\nexport function multiProviderParentChildDelta(parent: Injector, child: Injector, token: any) {\n  const childVals: RootModule[] = child.get(token, []);\n  const parentVals: RootModule[] = parent.get(token, []);\n  return childVals.filter(val => parentVals.indexOf(val) === -1);\n}\n"
  ]
}