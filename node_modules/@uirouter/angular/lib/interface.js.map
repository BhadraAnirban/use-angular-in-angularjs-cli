{
  "version": 3,
  "file": "interface.js",
  "sourceRoot": "",
  "sources": [
    "@uirouter/angular/interface.ts"
  ],
  "names": [],
  "mappings": "",
  "sourcesContent": [
    "/** @ng2api @module state */\n/** */\n\nimport { StateDeclaration, _ViewDeclaration, Transition, HookResult } from '@uirouter/core';\nimport { Type, Component } from '@angular/core';\nimport { NgModuleToLoad } from './lazyLoad/lazyLoadNgModule';\n\n/**\n * The StateDeclaration object is used to define a state or nested state.\n * It should be registered with the [[StateRegistry]].\n *\n * #### Example:\n * ```js\n * import {FoldersComponent} from \"./folders\";\n *\n * export function getAllFolders(FolderService) {\n *   return FolderService.list();\n * }\n *\n * // StateDeclaration object\n * export let foldersState = {\n *   name: 'folders',\n *   url: '/folders',\n *   component: FoldersComponent,\n *   resolve: [\n *     { token: 'allfolders', deps: [FolderService], resolveFn: getAllFolders }\n *   ]\n * }\n * ```\n */\nexport interface Ng2StateDeclaration extends StateDeclaration, Ng2ViewDeclaration {\n  /**\n   * An optional object used to define multiple named views.\n   *\n   * Each key is the name of a view, and each value is a [[Ng2ViewDeclaration]].\n   * Unnamed views are internally renamed to `$default`.\n   *\n   * A view's name is used to match an active `<ui-view>` directive in the DOM.  When the state\n   * is entered, the state's views are activated and then matched with active `<ui-view>` directives:\n   *\n   * - The view's name is processed into a ui-view target:\n   *   - ui-view address: an address to a ui-view\n   *   - state anchor: the state to anchor the address to\n   *\n   *  Examples:\n   *\n   *  Targets three named ui-views in the parent state's template\n   *\n   * #### Example:\n   * ```js\n   * views: {\n   *   header: {component: HeaderComponent},\n   *   body: {component: BodyComponent},\n   *   footer: {component: FooterComponent}\n   * }\n   * ```\n   *\n   * #### Example:\n   * ```js\n   * // Targets named ui-view=\"header\" in the template of the ancestor state 'top'\n   * // and the named `ui-view=\"body\" from the parent state's template.\n   * views: {\n   *   'header@top': {component: MsgHeaderComponent},\n   *   'body': {component: MessagesComponent}\n   * }\n   * ```\n   *\n   * ## View targeting details\n   *\n   * There are a few styles of view addressing/targeting.  The most common is a simple `ui-view` name\n   *\n   *\n   * #### Simple ui-view name\n   *\n   * Addresses without an `@` are anchored to the parent state.\n   *\n   * #### Example:\n   * ```js\n   * // target the `<div ui-view='foo'></div>` created in the parent state's view\n   * views: { foo: {...} }\n   * ```\n   *\n   * #### View name anchored to a state\n   *\n   * You can anchor the `ui-view` name to a specific state by including an `@`\n   *\n   * @example\n   *\n   * ```js\n   *\n   * // target the `<div ui-view='foo'></div>` which was created in a\n   * // view owned by the state `bar.baz`\n   * views: { 'foo@bar.baz': {...} }\n   * ```\n   *\n   * #### Absolute addressing\n   *\n   * You can address a `ui-view` absolutely, using dotted notation, by prefixing the address with a `!`.  Dotted\n   * addresses map to the hierarchy of `ui-view`s active in the DOM:\n   *\n   * #### Example:\n   * ```js\n   * // absolutely target the `<div ui-view='nested'></div>`... which was created\n   * // in the unnamed/$default root `<ui-view></ui-view>`\n   * views: { '!$default.nested': {...} }\n   * ```\n   *\n   * #### Relative addressing\n   *\n   * Absolute addressing is actually relative addressing, only anchored to the unnamed root state.  You can also use\n   * relative addressing anchored to any state, in order to target a target deeply nested `ui-views`:\n   *\n   * #### Example:\n   * ```js\n   *\n   * // target the `<div ui-view='bar'></div>`... which was created inside the\n   * // `<div ui-view='bar'></div>`... which was created inside the parent state's template.\n   * views: { 'foo.bar': {...} }\n   * ```\n   *\n   * #### Example:\n   * ```js\n   * // target the `<div ui-view='bar'></div>`...  which was created in\n   * // `<div ui-view='foo'></div>`... which was created in a template crom the state `baz.qux`\n   * views: { 'foo.bar@baz.qux': {...} }\n   *\n   * ---\n   *\n   * ## State `component:` and `views:` incompatiblity\n   *\n   * If a state has a `views` object, the state-level `component:` property is ignored.  Therefore,\n   * if _any view_ for a state is declared in the `views` object, then _all of the state's views_ must be defined in\n   * the `views` object.\n   */\n  views?: { [key: string]: Ng2ViewDeclaration };\n\n  /**\n   * A string or function used to lazy load an `NgModule`\n   *\n   * The `loadChildren` property should be added to a Future State (a lazy loaded state whose name ends in `.**`).\n   * The Future State is a placeholder for a tree of states that will be lazy loaded in the future.\n   *\n   * When the future state is activated, the `loadChildren` property will lazy load an `NgModule`\n   * which contains the fully loaded states.\n   * The `NgModule` should contain the fully loaded states which will be registered.\n   * The fully loaded states will replace the temporary future states once lazy loading is complete.\n   *\n   * ---\n   *\n   * When `loadChildren` is a string, it should be a relative path to the module code that will be lazy loaded.\n   * It should follow the semantics of the Angular Router's `loadChildren` property.\n   * The string will be split in half on the hash character (`#`).\n   * The first half is the path to the module.\n   * The last half is the named export of the `NgModule` inside the ES6 module.\n   *\n   * #### Example:\n   *\n   * home.module.ts\n   *\n   * ```\n   * @NgModule({... })\n   * export class HomeModule {};\n   * ```\n   *\n   * ```js\n   * var futureState = {\n   *   name: 'home.**',\n   *   url: '/home',\n   *   loadChildren: './home/home.module#HomeModule')\n   * }\n   * ```\n   *\n   *\n   * As a function, it should return a promise for the `NgModule`\n   *\n   * #### Example:\n   * ```js\n   * var futureState = {\n   *   name: 'home.**',\n   *   url: '/home',\n   *   loadChildren: () => System.import('./home/home.module')\n   *       .then(result => result.HomeModule);\n   * }\n   * ```\n   *\n   * #### Example:\n   * This shows the load function being exported for compatibility with the AoT compiler.\n   * ```js\n   * export function loadHomeModule() {\n   *   return System.import('./home/home.module')\n   *       .then(result => result.HomeModule);\n   * }\n   *\n   * var futureState = {\n   *   name: 'home.**',\n   *   url: '/home',\n   *   loadChildren: loadHomeModule\n   * }\n   * ```\n   */\n  loadChildren?: NgModuleToLoad;\n}\n\nexport interface Ng2ViewDeclaration extends _ViewDeclaration {\n  /**\n   * The `Component` class to use for this view.\n   *\n   * A property of [[Ng2StateDeclaration]] or [[Ng2ViewDeclaration]]:\n   *\n   * ### The component class which will be used for this view.\n   *\n   * #### Example:\n   * ```js\n   * .state('profile', {\n   *   // Use the <my-profile></my-profile> component for the Unnamed view\n   *   component: MyProfileComponent,\n   * }\n   *\n   * .state('messages', {\n   *   // use the <nav-bar></nav-bar> component for the view named 'header'\n   *   // use the <message-list></message-list> component for the view named 'content'\n   *   views: {\n   *     header: { component: NavBar },\n   *     content: { component: MessageList }\n   *   }\n   * }\n   *\n   * // Named views shorthand:\n   * // Inside a \"views:\" block, a Component class (NavBar) is shorthand for { component: NavBar }\n   * .state('contacts', {\n   *   // use the <nav-bar></nav-bar> component for the view named 'header'\n   *   // use the <contact-list></contact-list> component for the view named 'content'\n   *   views: {\n   *     header: NavBar,\n   *     content: ContactList\n   *   }\n   * }\n   * ```\n   *\n   * ### Accessing Resolve Data\n   *\n   * The component can access the Transition's [[Ng2StateDeclaration.resolve]] data in one of two ways:\n   *\n   * 1) Using Dependency Injection in the component constructor\n   *\n   * (using Typescript)\n   * ```js\n   * class MyComponent {\n   *   constructor(@Inject(\"myResolveData\") public resolveValueA, resolveValueB: public SomeClass) {\n   *   }\n   * }\n   * ```\n   *\n   * (using ES6/7/babel)\n   * ```js\n   * class MyComponent {\n   *   static get parameters() {\n   *     return [[\"myResolveData\"], [MyResolveClass]];\n   *   }\n   *   constructor(resolveValueA, resolveValueB) {\n   *     this.resolveValueA = resolveValueA;\n   *     this.resolveValueB = resolveValueB;\n   *   }\n   * }\n   * ```\n   *\n   * See also: https://github.com/shuhei/babel-plugin-angular2-annotations\n   *\n   * 2) Using a component input\n   *\n   * Note: To bind a resolve to a component input, the resolves must `provide:` a string value\n   *\n   * ```js\n   * @Component() {\n   *   inputs: ['resolveValueA']\n   * }\n   * class MyComponent {\n   *   myResolveValueA;\n   *   @Input() resolveValueB;\n   *   @Input(\"resolveValueC\") resolveValueC;\n   *\n   *   constructor() {\n   *   }\n   * }\n   * ```\n   */\n  component?: Type<any>;\n\n  /**\n   * An object which maps `resolve` keys to [[component]] `bindings`.\n   *\n   * A property of [[Ng2StateDeclaration]] or [[Ng2ViewDeclaration]]:\n   *\n   * When using a [[component]] declaration (`component: MyComponent`), each input binding for the component is supplied\n   * data from a resolve of the same name, by default.  You may supply data from a different resolve name by mapping it here.\n   * This might be useful if you want to reuse the same resolve value with various components with different input binding names.\n   *\n   * Each key in this object is the name of one of the component's input bindings.\n   * Each value is the name of the resolve that should be provided to that binding.\n   *\n   * Any component bindings that are omitted from this map get the default behavior of mapping to a resolve of the * same name.\n   *\n   * #### Example:\n   * ```js\n   * export const fooState = {\n   *   name: 'foo',\n   *   component: MyComponent,\n   *   resolve: [\n   *     { token: 'users', deps: [UserService], resolveFn: getUsers }\n   *   ],\n   *   bindings: {\n   *     resolveData: 'users'\n   *   }\n   * }\n   *\n   * export function getUsers(userservice) {\n   *   return userservice.getUsers();\n   * }\n   *\n   * @Component() {\n   * }\n   * class MyComponent {\n   *   @Input() resolveData;\n   *   constructor() { }\n   * }\n   * ```\n   *\n   */\n  bindings?: { [key: string]: string };\n}\n\n/**\n * The shape of a controller for a view (and/or component), defining the controller callbacks.\n *\n * A UI-Router view has an Angular `Component` (see [[Ng2ViewDeclaration.component]]).\n * The `Component` may define component-level hooks which UI-Router will call at the appropriate times.\n * These callbacks are similar to Transition Hooks ([[IHookRegistry]]), but are only called if the view/component is currently active.\n *\n * This interface defines the UI-Router component callbacks.\n */\nexport interface Ng2Component extends Component {\n  /**\n   * This callback is called when parameter values change\n   *\n   * This callback is used to respond dynamic parameter values changing.\n   * It is called when a transition changed one or more dynamic parameter values,\n   * and the routed component was not destroyed.\n   *\n   * It receives two parameters:\n   *\n   * - An object with (only) changed parameter values.\n   *   The keys are the parameter names and the values are the new parameter values.\n   * - The [[Transition]] which changed the parameter values.\n   *\n   * #### Example:\n   * ```js\n   * @Component({\n   *   template: '<input type=\"text\">'\n   * })\n   * class MyComponent {\n   *   uiOnParamsChanged(newParams: { [paramName: string]: any }, trans: Transition) {\n   *     Object.keys(newParams).forEach(paramName => {\n   *       console.log(`${paramName} changed to ${newParams[paramName]}`)\n   *     });\n   *   }\n   * }\n   * ```\n   */\n  uiOnParamsChanged?(newParams: { [paramName: string]: any }, trans?: Transition): void;\n\n  /**\n   * This callback is called when the routed component's state is about to be exited.\n   *\n   * The callback can be used to cancel or alter the new Transition that would otherwise exit the component's state.\n   *\n   * This callback is used to inform a view that it is about to be exited, due to a new [[Transition]].\n   * The callback can ask for user confirmation, and cancel or alter the new Transition.  The callback should\n   * return a value, or a promise for a value.  If a promise is returned, the new Transition waits until the\n   * promise settles.\n   *\n   * Called when:\n   * - The component is still active inside a `ui-view`\n   * - A new Transition is about to run\n   * - The new Transition will exit the view's state\n   *\n   * Called with:\n   * - The `Transition` that is about to exit the component's state\n   *\n   * #### Example:\n   * ```js\n   * @Component({\n   *   template: '<input type=\"text\">'\n   * })\n   * class MyComponent {\n   *   dirty = true;\n   *\n   *   constructor(public confirmService: confirmService) {\n   *\n   *   }\n   *\n   *   uiCanExit(newTransition: Transition) {\n   *     if (this.dirty && newTransition.to() !== 'logout') {\n   *       return this.confirmService.confirm(\"Exit without saving changes?\");\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * @return a hook result which may cancel or alter the pending Transition (see [[HookResult]])\n   */\n  uiCanExit?(newTransition?: Transition): HookResult;\n}\n"
  ]
}